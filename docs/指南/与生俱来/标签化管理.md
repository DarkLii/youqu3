# 标签化管理

## 使用说明

在 CSV 文件中写入标签：

| 脚本文件ID | 跳过原因 | 确认修复  |  废弃用例   | ...  |
| :--------: | :------: | :-------: | :---------: | ---- |
|    001     | skip-xxx | fixed-xxx | removed-xxx | ...  |

## CSV文件与脚本对应关系

1.  在子项目目录下新建 CSV文件，用于保存用例标签，以 用例脚本的 py 文件去掉首字符串 "`test_`" ，去掉用例序号后的字符串，取`中间的名称`作为 csv 文件的文件名 。

   ::: tip 举例

   相册的用例文件为 `test_album_001.py`，`001` 表示用例的ID（也可以是自定义的数字代表用例序号），此时 CSV 文件名就应为 `album.csv` ；

   :::

2.  `第 1 列`为 `脚本文件ID`，从`第 2 列`之后的所有列都是一个用例标签，标签可以无序，可以随意新增。

   ::: tip 特殊标签

   `跳过原因`、`确认修复`、`废弃用例`是特殊的标签，后面会详细讲到

   :::

对于用例规模比较大的应用，比如文件管理器，建议分模块，每个模块建立一个 CSV 文件，所有 CSV 文件建议放在一个 `tags` 目录下。

是否分模块维护取决于应用的用例复杂度，但标签化管理的核心目的是集中化管理用例的标签，因此若 CSV 文件太多了也是一个很糟糕的事情。 

## 跳过用例

传统跳过用例的方式是在用例脚本里面给用例添加装饰器 (`@pytest.mark.skip`)，解除跳过时将装饰器代码删掉，这种方式需要修改用例代码，而通过 `csv` 文件来管理跳过用例则会方便很多;

将跳过用例操作也整合进入用例标签，在 `csv` 文件中新增一列为“跳过原因”；

### 1. 固定跳过

示例：

| 脚本文件ID | ...（各种用例标签） |       跳过原因        |
| :--------: | :-----------------: | :-------------------: |
|   679537   |         ...         | skip-受到某新需求影响 |

- 如果应用受到新需求影响需要跳过，则在此列备注具体的跳过原因。跳过的原因统一标签开头为 “`skip-XXX`”；
- 用例执行时判断 `csv` 文件里面跳过原因列是否存在跳过标签，存在跳过标签则用例也不会被执行，最终的用例状态会被标签为 `SKIPED`。

### 2. 条件判断跳过

在 `CSV` 文件中，`跳过原因`一栏中填写为 “`{函数名}-{参数}`”。

某些用例会因为不同的环境判断用例是否执行，常见的场景为在不同架构上判断是否执行，例如：`skipif_platform-aarch64`；

示例：

| 脚本文件ID | ...（各种用例标签） |           跳过原因           |
| :--------: | :-----------------: | :--------------------------: |
|    001     |         ...         | skipif_platform-aarch64&sw64 |

- 跳过的原因标签为 “`skipif_platform-`”  + 架构名，多个架构之间使用 “`&`” 拼接；
- 判断当前架构是否为 `arrch64` 或者 `sw64`，若是，则跳过用例不执行；

内置支持的条件跳过对象：

| 跳过对象              | 参数                                        | 说明                                                         |
| --------------------- | ------------------------------------------- | ------------------------------------------------------------ |
| `skipif_platform`     | (`x86_64`、`aarch64`、`loogarch64`、`sw64`) | 架构跳过                                                     |
| `skipif_not_platform` | (`x86_64`、`aarch64`、`loogarch64`、`sw64`) | 架构不跳过                                                   |
| `skipif_xdg_type`     | (`wayland` 、`x11`)                         | 系统显示协议跳过                                             |
| `skipif_cpu_name`     | /                                           | 使用 `sudo dmidecode -s system-product-name` 查看机器的 `cpu` 型号    剔除中横线和 `&` 符号，<br />比如：KLVV-W5821，标签记录为 KLVVW5821 |
| `skipif_not_cpu_name` | /                                           | 和上面逻辑相反                                               |

### 3.自定义跳过

在用例工程根目录下存放 `skipif.py`，自定义条件判断跳过的函数写在此文件中。

方法编写规范：

- 方法名必须以 `skipif` 开头；
- 方法必须有返回结果并且为布尔值（`True` 代表跳过，`False` 代表不跳过）；
- 方法只能有一个入参；

在用例收集阶段会以第一个 “`-`” 进行分割，截取的左侧字符串作为函数名，在 `skipif.py` 文件中查找是否有同名函数，并将截取的右侧作为参数传递给该函数，通过获取该函数返回的布尔值，返回 `True`，则用例不执行，返回 `False`，则执行该用例。

::: tip 重要

- 若函数需要多个参数，可自定义多个参数之间的连接符，连接符号不可使用下划线和逗号，推荐统一使用 `&` 符号；

- 若需要多个 skipif 条件判断组合，使用 `&&` 符号将两个方法分开，比如：`skipif_platform-aarch64&&skipif_xdg_type-wayland` ；

:::

## 确认修复

针对于某些用例修复后，但不能立即删除跳过原因（`skip-XXX`）的用例，新增一列标签名为 “`确认修复`”，作为标记该用例是否已经修复，固定填入字段为 “`fixed-已修复`”。这样这条用例即使同时标记了 `skip-XXX` 也会正常执行。

示例：

| 用例ID | ...（各种用例标签） |       跳过原因        |   确认修复   |
| :----: | :-----------------: | :-------------------: | :----------: |
| 679537 |         ...         | skip-受到某新需求影响 | fixed-已修复 |

【同时标记了`skip` 和 `fixed`，但仍然想要跳过用例】

当 “跳过原因” 和 “确认修复” 中同时填入后，命令行传递参数 `--ifixed yes`，则代码不会执行该条用例。

```bash
python3 manage.py run --ifixed yes
```

## 废弃用例

针对某些用例，由于需求变更，环境影响或评估不再适用于自动化测试时，用例需要废弃，则新增一列标签名为 “废弃用例”，该列存在 “removed-{废弃原因}”，则用例不会执行。

| 用例ID | ...（各种用例标签） |       跳过原因        |   确认修复   |    废弃用例    |
| :----: | :-----------------: | :-------------------: | :----------: | :------------: |
| 679537 |         ...         | skip-受到某新需求影响 | fixed-已修复 | removed-已废弃 |

![](https://pic.imgdb.cn/item/64f054ca661c6c8e54ff4f70.png)



## 文件格式

此配置文件需要维护大量的标签数据，且要方便能使用 `Excel` 打开进行编辑查看，更重要的是我们不想引入三方依赖，`CSV` 文件几乎是唯一能满足所有的要求的文件格式。

